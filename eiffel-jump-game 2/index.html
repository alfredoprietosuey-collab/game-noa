<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Salta y evita la Torre Eiffel</title>
  <style>
    :root{
      --bg1:#8fd3ff;
      --bg2:#eaf7ff;
      --ink:#101828;
      --card:#ffffffcc;
      --shadow: 0 20px 60px rgba(16,24,40,.18);
      --radius: 20px;
      --accent:#ff4d7d;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--ink);
      display:grid;
      place-items:center;
      background: radial-gradient(1200px 800px at 20% 20%, var(--bg2), var(--bg1));
      overflow:hidden;
    }
    #wrap{
      width:min(980px, 94vw);
      height:min(560px, 78vh);
      position:relative;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      background: linear-gradient(#bfe7ff, #ffffff);
    }
    canvas{width:100%;height:100%;display:block}
    #hud{
      position:absolute;
      top:14px; left:14px; right:14px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      pointer-events:none;
      font-weight:700;
      text-shadow: 0 2px 10px rgba(0,0,0,.12);
    }
    .pill{
      background:#ffffffc7;
      border:1px solid rgba(16,24,40,.10);
      backdrop-filter: blur(10px);
      padding:10px 12px;
      border-radius:999px;
      box-shadow: 0 10px 24px rgba(16,24,40,.10);
    }
    .hint{
      font-weight:600;
      opacity:.9;
      font-size:13px;
      white-space:nowrap;
    }
    #overlay, #voucher{
      position:absolute; inset:0;
      display:grid; place-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.72), rgba(255,255,255,.32));
      backdrop-filter: blur(6px);
    }
    #overlay.hidden, #voucher.hidden{display:none}
    .card{
      width:min(560px, 92%);
      background: var(--card);
      border: 1px solid rgba(16,24,40,.10);
      border-radius: 24px;
      padding: 22px 22px 18px;
      box-shadow: var(--shadow);
    }
    h1{
      margin:0 0 8px;
      font-size: clamp(22px, 3.4vw, 34px);
      letter-spacing:-.02em;
    }
    p{margin:0 0 12px; line-height:1.35; font-size:15px; opacity:.92}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    button{
      pointer-events:auto;
      appearance:none;
      border:0;
      border-radius: 14px;
      padding: 12px 14px;
      font-weight:800;
      cursor:pointer;
      background: var(--ink);
      color:white;
      box-shadow: 0 14px 28px rgba(16,24,40,.18);
      transition: transform .06s ease;
    }
    button:active{transform: translateY(1px)}
    button.secondary{
      background: #ffffff;
      color: var(--ink);
      border:1px solid rgba(16,24,40,.14);
      box-shadow: 0 12px 24px rgba(16,24,40,.10);
    }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(255,77,125,.12);
      border: 1px solid rgba(255,77,125,.25);
      font-weight:800;
      color: #b01238;
      width: fit-content;
    }
    .code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(16,24,40,.06);
      border:1px dashed rgba(16,24,40,.18);
      padding: 10px 12px;
      border-radius: 14px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-top: 10px;
    }
    .code span{user-select:all}
    .tiny{opacity:.75; font-size:12px; margin-top:10px}
    a{color:inherit}
  </style>
</head>
<body>
  <div id="wrap" aria-label="Juego: salta y evita la Torre Eiffel">
    <canvas id="game" width="980" height="560"></canvas>

    <div id="hud">
      <div class="pill">Saltos: <span id="score">0</span>/10</div>
      <div class="pill hint">Espacio / ‚Üë / Click / Tap para saltar ‚Ä¢ R para reiniciar</div>
    </div>

    <div id="overlay">
      <div class="card">
        <div class="badge">üóº Runner rom√°ntico</div>
        <h1>Salta y evita la Torre Eiffel</h1>
        <p>Tu misi√≥n: esquivar las torres con <b>10 saltos</b> seguidos. Si lo logras, se desbloquea un vale especial. üòâ</p>
        <div class="row">
          <button id="startBtn">Empezar</button>
          <button class="secondary" id="muteBtn" aria-pressed="false" title="Sonido">üîä Sonido</button>
        </div>
        <p class="tiny">Tip: si est√°s en m√≥vil, toca la pantalla para saltar.</p>
      </div>
    </div>

    <div id="voucher" class="hidden">
      <div class="card">
        <div class="badge">üéÅ Desbloqueado</div>
        <h1>Vale por una experiencia distinta</h1>
        <p>Presenta este vale cuando quieras canjearlo. (S√≠, vale de verdad en el mundo real üòÑ)</p>

        <div class="code">
          <span id="voucherCode">VALE-EXPERIENCIA-10</span>
          <button class="secondary" id="copyBtn">Copiar</button>
        </div>

        <div class="row" style="margin-top:12px">
          <button id="playAgainBtn">Jugar otra vez</button>
          <button class="secondary" id="closeVoucherBtn">Cerrar</button>
        </div>

        <p class="tiny">Puedes cambiar el texto del vale en <code>index.html</code>. Tambi√©n puedes ajustar el objetivo (10) en <code>GOAL</code>.</p>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== Config ======
  const GOAL = 10;

  // ====== Canvas setup (HiDPI) ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function fitCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }
  window.addEventListener('resize', fitCanvas);

  // ====== UI ======
  const overlay = document.getElementById('overlay');
  const voucher = document.getElementById('voucher');
  const scoreEl = document.getElementById('score');
  const startBtn = document.getElementById('startBtn');
  const muteBtn = document.getElementById('muteBtn');
  const copyBtn = document.getElementById('copyBtn');
  const playAgainBtn = document.getElementById('playAgainBtn');
  const closeVoucherBtn = document.getElementById('closeVoucherBtn');

  let muted = false;
  muteBtn.addEventListener('click', () => {
    muted = !muted;
    muteBtn.textContent = muted ? 'üîá Silencio' : 'üîä Sonido';
    muteBtn.setAttribute('aria-pressed', String(muted));
  });

  copyBtn.addEventListener('click', async () => {
    const text = document.getElementById('voucherCode').textContent;
    try{
      await navigator.clipboard.writeText(text);
      copyBtn.textContent = '¬°Copiado!';
      setTimeout(() => copyBtn.textContent = 'Copiar', 900);
    }catch(e){
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      copyBtn.textContent = '¬°Copiado!';
      setTimeout(() => copyBtn.textContent = 'Copiar', 900);
    }
  });

  playAgainBtn.addEventListener('click', () => {
    voucher.classList.add('hidden');
    startGame(true);
  });

  closeVoucherBtn.addEventListener('click', () => {
    voucher.classList.add('hidden');
  });

  // ====== Assets ======
  const face = new Image();
  face.src = 'assets/face_sprite.png';
  let faceReady = false;
  face.onload = () => faceReady = true;

  // ====== Tiny sound (no external files) ======
  let audioCtx = null;
  function beep(freq, duration=0.05, type='sine', gain=0.03){
    if (muted) return;
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + duration);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + duration);
  }

  // ====== Game state ======
  const state = {
    running: false,
    over: false,
    won: false,
    time: 0,
    score: 0,
    speed: 340, // px/s
    spawnTimer: 0,
    groundY: 0,
    shake: 0,
    clouds: [],
    particles: []
  };

  const player = {
    x: 120,
    y: 0,
    r: 28,
    vy: 0,
    onGround: true
  };

  const obstacles = [];

  // ====== Helpers ======
  function rand(a,b){ return a + Math.random()*(b-a); }

  function resetWorld(h, w){
    state.time = 0;
    state.score = 0;
    state.speed = 340;
    state.spawnTimer = 0.8;
    state.over = false;
    state.won = false;
    state.shake = 0;
    obstacles.length = 0;
    state.particles.length = 0;
    state.clouds = Array.from({length: 6}, () => ({
      x: rand(0, w),
      y: rand(25, 160),
      s: rand(0.5, 1.2),
      vx: rand(8, 18),
    }));
    player.y = h - 90 - player.r;
    player.vy = 0;
    player.onGround = true;
  }

  function jump(){
    if(!state.running || state.over || state.won) return;
    if(player.onGround){
      // Un poco m√°s de salto para que las torres sean disfrutables de esquivar
      player.vy = -840;
      player.onGround = false;
      beep(520, 0.06, 'square', 0.025);
    }
  }

  function restart(){
    startGame(true);
  }

  function drawRoundedRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // Stylized Eiffel tower, drawn in local coords 0..200 x 0..300
  function drawEiffel(x, y, w, h){
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(w/200, h/300);

    // soft shadow
    ctx.fillStyle = 'rgba(0,0,0,.12)';
    ctx.beginPath();
    ctx.ellipse(100, 296, 70, 10, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#3b3b3b';
    ctx.strokeStyle = 'rgba(255,255,255,.06)';
    ctx.lineWidth = 4;

    // legs
    ctx.beginPath();
    ctx.moveTo(35,300);
    ctx.lineTo(80,300);
    ctx.lineTo(100,205);
    ctx.lineTo(83,205);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(120,300);
    ctx.lineTo(165,300);
    ctx.lineTo(117,205);
    ctx.lineTo(100,205);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // arch cutout (simulate by drawing sky color over it)
    ctx.fillStyle = 'rgba(255,255,255,.55)';
    ctx.beginPath();
    ctx.moveTo(73,300);
    ctx.quadraticCurveTo(100,260, 127,300);
    ctx.lineTo(73,300);
    ctx.closePath();
    ctx.fill();

    // mid body
    ctx.fillStyle = '#3b3b3b';
    ctx.beginPath();
    ctx.moveTo(83,205);
    ctx.lineTo(117,205);
    ctx.lineTo(108,150);
    ctx.lineTo(92,150);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // upper body
    ctx.beginPath();
    ctx.moveTo(92,150);
    ctx.lineTo(108,150);
    ctx.lineTo(104,90);
    ctx.lineTo(96,90);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // top spire
    ctx.beginPath();
    ctx.moveTo(96,90);
    ctx.lineTo(104,90);
    ctx.lineTo(101,40);
    ctx.lineTo(99,40);
    ctx.closePath();
    ctx.fill();

    // antenna
    ctx.fillRect(99, 10, 2, 30);

    // cross bars
    ctx.fillStyle = 'rgba(255,255,255,.10)';
    ctx.fillRect(70, 210, 60, 8);
    ctx.fillRect(78, 155, 44, 7);
    ctx.fillRect(86, 115, 28, 6);

    ctx.restore();
  }

  function collideCircleAABB(cx, cy, r, rx, ry, rw, rh){
    const nx = Math.max(rx, Math.min(cx, rx+rw));
    const ny = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - nx;
    const dy = cy - ny;
    return (dx*dx + dy*dy) <= r*r;
  }

  // ====== Particles / confetti ======
  function burst(x, y, n=70){
    for(let i=0;i<n;i++){
      state.particles.push({
        x, y,
        vx: rand(-240, 240),
        vy: rand(-420, -80),
        g: rand(900, 1400),
        r: rand(2, 4),
        life: rand(0.8, 1.4),
        t: 0,
        hue: rand(0, 360)
      });
    }
  }

  function updateParticles(dt){
    for(const p of state.particles){
      p.t += dt;
      p.vy += p.g * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= Math.pow(0.995, dt*60);
    }
    // keep survivors
    for(let i=state.particles.length-1;i>=0;i--){
      if(state.particles[i].t > state.particles[i].life) state.particles.splice(i,1);
    }
  }

  function drawParticles(){
    for(const p of state.particles){
      const a = 1 - (p.t / p.life);
      ctx.fillStyle = `hsla(${p.hue}, 90%, 55%, ${a})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // ====== Main loop ======
  let last = 0;

  function step(ts){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    state.groundY = h - 78;

    if(!last) last = ts;
    const dt = Math.min(0.033, (ts - last) / 1000);
    last = ts;

    if(state.running){
      update(dt, w, h);
    } else {
      // idle drift for clouds + subtle movement
      for(const c of state.clouds){
        c.x -= c.vx * c.s * dt;
        if(c.x < -140) { c.x = w + rand(20, 120); c.y = rand(25, 160); c.s = rand(0.5, 1.2); }
      }
      state.time += dt * 0.6;
      updateParticles(dt);
    }

    render(w, h);
    requestAnimationFrame(step);
  }

  function update(dt, w, h){
    state.time += dt;

    // Clouds
    for(const c of state.clouds){
      c.x -= c.vx * c.s * dt;
      if(c.x < -140) { c.x = w + rand(20, 120); c.y = rand(25, 160); c.s = rand(0.5, 1.2); }
    }

    if(state.over || state.won){
      updateParticles(dt);
      return;
    }

    // dificultad (un poco m√°s amable)
    state.speed = Math.min(680, 340 + state.score * 22);

    // spawn obstacles
    state.spawnTimer -= dt;
    if(state.spawnTimer <= 0){
      // Torres m√°s bajas (antes muchas eran imposibles de saltar)
      const baseH = rand(110, 170);
      const oh = baseH;
      const ow = oh * (200/300); // keep ratio
      obstacles.push({
        x: w + 40,
        y: state.groundY - oh,
        w: ow,
        h: oh,
        passed: false
      });
      // M√°s separaci√≥n entre torres, sobre todo cuando sube la velocidad
      const minGap = Math.max(0.9, 1.35 - state.score * 0.03);
      state.spawnTimer = rand(minGap, minGap + 0.65);
    }

    // player physics
    const g = 2000;
    player.vy += g * dt;
    player.y += player.vy * dt;

    const floorY = state.groundY - player.r;
    if(player.y >= floorY){
      player.y = floorY;
      player.vy = 0;
      player.onGround = true;
    }

    // obstacles move & scoring
    for(const o of obstacles){
      o.x -= state.speed * dt;
      if(!o.passed && (o.x + o.w) < (player.x - player.r)){
        o.passed = true;
        state.score += 1;
        scoreEl.textContent = state.score;
        beep(740, 0.04, 'triangle', 0.02);
        if(state.score >= GOAL){
          win(w, h);
          return;
        }
      }
    }

    // remove offscreen
    while(obstacles.length && obstacles[0].x + obstacles[0].w < -50){
      obstacles.shift();
    }

    // collision
    for(const o of obstacles){
      const hit = collideCircleAABB(player.x, player.y, player.r*0.86, o.x+12, o.y+10, o.w-24, o.h-20);
      if(hit){
        gameOver(w, h);
        return;
      }
    }

    updateParticles(dt);
  }

  function gameOver(w, h){
    state.over = true;
    state.shake = 0.25;
    beep(160, 0.12, 'sawtooth', 0.03);
    burst(player.x, player.y, 40);
    setTimeout(() => {
      overlay.classList.remove('hidden');
      overlay.querySelector('h1').textContent = '¬°Auch! Torre Eiffel üòÖ';
      overlay.querySelector('p').innerHTML = 'Pulsa <b>Empezar</b> para intentarlo de nuevo. (Objetivo: <b>' + GOAL + '</b> saltos)';
      startBtn.textContent = 'Reintentar';
    }, 300);
  }

  function win(w, h){
    state.won = true;
    beep(880, 0.08, 'square', 0.03);
    beep(988, 0.08, 'square', 0.03);
    beep(1175, 0.10, 'square', 0.03);
    burst(w*0.5, h*0.35, 120);
    setTimeout(() => {
      voucher.classList.remove('hidden');
    }, 450);
  }

  function render(w, h){
    ctx.clearRect(0,0,w,h);

    // background sky
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, '#bfe7ff');
    grad.addColorStop(0.55, '#f3fbff');
    grad.addColorStop(1, '#ffffff');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,w,h);

    // clouds
    for(const c of state.clouds){
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = '#ffffff';
      const x = c.x, y = c.y;
      ctx.beginPath();
      ctx.ellipse(x, y, 44*c.s, 18*c.s, 0, 0, Math.PI*2);
      ctx.ellipse(x+34*c.s, y+3*c.s, 34*c.s, 14*c.s, 0, 0, Math.PI*2);
      ctx.ellipse(x-32*c.s, y+5*c.s, 28*c.s, 12*c.s, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // far city line
    ctx.fillStyle = 'rgba(16,24,40,.06)';
    ctx.fillRect(0, state.groundY - 26, w, 2);

    // ground
    const g2 = ctx.createLinearGradient(0, state.groundY, 0, h);
    g2.addColorStop(0, '#ffffff');
    g2.addColorStop(1, '#f2f4f7');
    ctx.fillStyle = g2;
    ctx.fillRect(0, state.groundY, w, h - state.groundY);

    // little dots on ground
    ctx.fillStyle = 'rgba(16,24,40,.06)';
    for(let i=0;i<Math.ceil(w/28);i++){
      const dx = (i*28 - (state.time*120 % 28));
      ctx.beginPath();
      ctx.arc(dx, state.groundY + 22, 2.3, 0, Math.PI*2);
      ctx.fill();
    }

    // obstacles
    for(const o of obstacles){
      drawEiffel(o.x, o.y, o.w, o.h);
    }

    // player shadow
    ctx.fillStyle = 'rgba(0,0,0,.14)';
    ctx.beginPath();
    ctx.ellipse(player.x, state.groundY + 6, player.r*0.95, 9, 0, 0, Math.PI*2);
    ctx.fill();

    // player sprite
    if(faceReady){
      const size = player.r*2.25;
      ctx.drawImage(face, player.x - size/2, player.y - size/2, size, size);
    } else {
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
      ctx.fill();
    }

    drawParticles();
  }

  // ====== Start / Controls ======
  function startGame(keepOverlay=false){
    fitCanvas();
    const rect = canvas.getBoundingClientRect();
    resetWorld(rect.height, rect.width);
    scoreEl.textContent = '0';
    state.running = true;
    last = 0;

    if(!keepOverlay){
      overlay.classList.remove('hidden');
    }
    overlay.classList.add('hidden');
    overlay.querySelector('h1').textContent = 'Salta y evita la Torre Eiffel';
    overlay.querySelector('p').innerHTML = 'Tu misi√≥n: esquivar las torres con <b>' + GOAL + '</b> saltos seguidos. Si lo logras, se desbloquea un vale especial. üòâ';
    startBtn.textContent = 'Empezar';
      }

  startBtn.addEventListener('click', () => startGame(true));

  // keyboard
  window.addEventListener('keydown', (e) => {
    if(e.code === 'Space' || e.code === 'ArrowUp'){
      e.preventDefault();
      if(!state.running){ startGame(true); return; }
      if(overlay && !overlay.classList.contains('hidden')) startGame(true);
      jump();
    }
    if(e.code === 'KeyR'){ restart(); }
  }, {passive:false});

  // pointer
  canvas.addEventListener('pointerdown', (e) => {
    if(overlay && !overlay.classList.contains('hidden')) { startGame(true); return; }
    jump();
  });

  // kick things off visually (paused)
  fitCanvas();
  {
    const rect = canvas.getBoundingClientRect();
    resetWorld(rect.height, rect.width);
    scoreEl.textContent = '0';
  }
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
